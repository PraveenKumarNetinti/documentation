---
title: 'Authentication Serializers, Views, Services & Strategies'
description: 'Continuing with the authentication system implementation.'
sidebarTitle: "Authentication Serializers"
---

## Authentication Serializers

<Info>
Serializers handle data validation, transformation, and provide a clean API interface for authentication operations.
</Info>

### `apps/authentication/serializers.py`

```python
"""
Authentication serializers.
"""
from rest_framework import serializers
from rest_framework_simplejwt.serializers import TokenObtainPairSerializer
from django.contrib.auth import authenticate
from django.contrib.auth.password_validation import validate_password
from django.utils.translation import gettext_lazy as _
from django.utils import timezone
from .models import User, AuthSession, MagicLink


class UserSerializer(serializers.ModelSerializer):
    """
    Serializer for User model.
    """
    class Meta:
        model = User
        fields = [
            'id', 
            'email', 
            'display_name', 
            'avatar_url',
            'email_verified',
            'timezone',
            'locale',
            'last_login_at',
            'created_at',
            'updated_at',
        ]
        read_only_fields = [
            'id', 
            'email', 
            'email_verified', 
            'last_login_at',
            'created_at', 
            'updated_at',
        ]


class UserProfileUpdateSerializer(serializers.ModelSerializer):
    """
    Serializer for updating user profile.
    """
    class Meta:
        model = User
        fields = [
            'display_name',
            'avatar_url',
            'timezone',
            'locale',
        ]


class UserRegistrationSerializer(serializers.ModelSerializer):
    """
    Serializer for user registration.
    """
    password = serializers.CharField(
        write_only=True,
        required=True,
        style={'input_type': 'password'},
        validators=[validate_password]
    )
    password_confirm = serializers.CharField(
        write_only=True,
        required=True,
        style={'input_type': 'password'}
    )

    class Meta:
        model = User
        fields = [
            'email',
            'display_name',
            'password',
            'password_confirm',
        ]

    def validate_email(self, value):
        """Validate email is unique."""
        email = value.lower()
        if User.objects.filter(email=email).exists():
            raise serializers.ValidationError(
                _("A user with this email already exists.")
            )
        return email

    def validate(self, attrs):
        """Validate passwords match."""
        if attrs['password'] != attrs['password_confirm']:
            raise serializers.ValidationError({
                'password_confirm': _("Passwords do not match.")
            })
        return attrs

    def create(self, validated_data):
        """Create new user."""
        validated_data.pop('password_confirm')
        password = validated_data.pop('password')
        
        user = User.objects.create_user(
            password=password,
            **validated_data
        )
        return user


class LoginSerializer(serializers.Serializer):
    """
    Serializer for email/password login.
    """
    email = serializers.EmailField(required=True)
    password = serializers.CharField(
        required=True,
        write_only=True,
        style={'input_type': 'password'}
    )

    def validate_email(self, value):
        """Normalize email."""
        return value.lower()

    def validate(self, attrs):
        """Validate credentials."""
        email = attrs.get('email')
        password = attrs.get('password')

        user = authenticate(
            request=self.context.get('request'),
            email=email,
            password=password
        )

        if not user:
            raise serializers.ValidationError({
                'non_field_errors': [_("Invalid email or password.")]
            })

        if not user.is_active:
            raise serializers.ValidationError({
                'non_field_errors': [_("This account has been deactivated.")]
            })

        attrs['user'] = user
        return attrs


class CustomTokenObtainPairSerializer(TokenObtainPairSerializer):
    """
    Custom JWT token serializer with additional claims.
    """
    @classmethod
    def get_token(cls, user):
        token = super().get_token(user)

        # Add custom claims
        token['email'] = user.email
        token['display_name'] = user.display_name
        token['email_verified'] = user.email_verified

        return token


class TokenRefreshSerializer(serializers.Serializer):
    """
    Serializer for token refresh.
    """
    refresh = serializers.CharField(required=True)


class PasswordChangeSerializer(serializers.Serializer):
    """
    Serializer for password change.
    """
    current_password = serializers.CharField(
        required=True,
        write_only=True,
        style={'input_type': 'password'}
    )
    new_password = serializers.CharField(
        required=True,
        write_only=True,
        style={'input_type': 'password'},
        validators=[validate_password]
    )
    new_password_confirm = serializers.CharField(
        required=True,
        write_only=True,
        style={'input_type': 'password'}
    )

    def validate_current_password(self, value):
        """Validate current password is correct."""
        user = self.context['request'].user
        if not user.check_password(value):
            raise serializers.ValidationError(
                _("Current password is incorrect.")
            )
        return value

    def validate(self, attrs):
        """Validate new passwords match."""
        if attrs['new_password'] != attrs['new_password_confirm']:
            raise serializers.ValidationError({
                'new_password_confirm': _("Passwords do not match.")
            })
        return attrs


class PasswordResetRequestSerializer(serializers.Serializer):
    """
    Serializer for requesting password reset.
    """
    email = serializers.EmailField(required=True)

    def validate_email(self, value):
        """Normalize email."""
        return value.lower()


class PasswordResetConfirmSerializer(serializers.Serializer):
    """
    Serializer for confirming password reset.
    """
    token = serializers.CharField(required=True)
    password = serializers.CharField(
        required=True,
        write_only=True,
        style={'input_type': 'password'},
        validators=[validate_password]
    )
    password_confirm = serializers.CharField(
        required=True,
        write_only=True,
        style={'input_type': 'password'}
    )

    def validate(self, attrs):
        """Validate passwords match."""
        if attrs['password'] != attrs['password_confirm']:
            raise serializers.ValidationError({
                'password_confirm': _("Passwords do not match.")
            })
        return attrs


class MagicLinkRequestSerializer(serializers.Serializer):
    """
    Serializer for requesting magic link.
    """
    email = serializers.EmailField(required=True)

    def validate_email(self, value):
        """Normalize email."""
        return value.lower()


class MagicLinkVerifySerializer(serializers.Serializer):
    """
    Serializer for verifying magic link.
    """
    token = serializers.CharField(required=True, max_length=100)


class EmailVerificationRequestSerializer(serializers.Serializer):
    """
    Serializer for requesting email verification.
    """
    pass  # No input needed, uses current user


class EmailVerificationConfirmSerializer(serializers.Serializer):
    """
    Serializer for confirming email verification.
    """
    token = serializers.CharField(required=True, max_length=100)


class AuthSessionSerializer(serializers.ModelSerializer):
    """
    Serializer for auth sessions.
    """
    is_current = serializers.SerializerMethodField()

    class Meta:
        model = AuthSession
        fields = [
            'id',
            'ip_address',
            'user_agent',
            'last_activity_at',
            'created_at',
            'is_current',
        ]

    def get_is_current(self, obj):
        """Check if this is the current session."""
        request = self.context.get('request')
        if not request:
            return False
        
        current_token = getattr(request, 'current_session_id', None)
        return str(obj.id) == current_token


class LogoutSerializer(serializers.Serializer):
    """
    Serializer for logout.
    """
    refresh = serializers.CharField(required=False, allow_blank=True)


class LogoutAllSerializer(serializers.Serializer):
    """
    Serializer for logout from all devices.
    """
    pass  # No input needed
```

---

## Authentication Services

### `apps/authentication/services.py`

```python
"""
Authentication business logic services.
"""
import logging
from datetime import timedelta
from typing import Optional, Tuple
from django.conf import settings
from django.utils import timezone
from django.db import transaction
from rest_framework_simplejwt.tokens import RefreshToken as JWTRefreshToken
from apps.core.utils import generate_random_token, generate_secure_hash
from apps.core.exceptions import ServiceException
from .models import User, AuthSession, RefreshToken, MagicLink
import uuid

logger = logging.getLogger(__name__)


class AuthenticationService:
    """
    Service for handling authentication operations.
    """

    @staticmethod
    def register_user(
        email: str,
        display_name: str,
        password: str,
        ip_address: Optional[str] = None
    ) -> User:
        """
        Register a new user.
        """
        with transaction.atomic():
            user = User.objects.create_user(
                email=email.lower(),
                display_name=display_name,
                password=password,
            )
            
            # Send verification email (async)
            from .tasks import send_email_verification
            send_email_verification.delay(str(user.id))
            
            logger.info(f"User registered: {email}", extra={
                'user_id': str(user.id),
                'ip_address': ip_address,
            })
            
            return user

    @staticmethod
    def login_user(
        user: User,
        ip_address: str,
        user_agent: str = '',
        device_fingerprint: str = ''
    ) -> Tuple[str, str, AuthSession]:
        """
        Login user and create session with tokens.
        Returns: (access_token, refresh_token, session)
        """
        with transaction.atomic():
            # Generate JWT tokens
            jwt_token = JWTRefreshToken.for_user(user)
            access_token = str(jwt_token.access_token)
            refresh_token = str(jwt_token)
            
            # Create session
            session = AuthSession.objects.create(
                user=user,
                token_hash=generate_secure_hash(access_token[:50]),
                refresh_token_hash=generate_secure_hash(refresh_token[:50]),
                ip_address=ip_address,
                user_agent=user_agent,
                device_fingerprint=device_fingerprint,
                expires_at=timezone.now() + timedelta(
                    minutes=settings.SIMPLE_JWT['REFRESH_TOKEN_LIFETIME'].total_seconds() / 60
                ),
            )
            
            # Create refresh token record
            family_id = uuid.uuid4()
            RefreshToken.objects.create(
                user=user,
                token_hash=generate_secure_hash(refresh_token),
                session=session,
                family_id=family_id,
                expires_at=session.expires_at,
            )
            
            # Update user last login
            user.update_last_login(ip_address)
            
            logger.info(f"User logged in: {user.email}", extra={
                'user_id': str(user.id),
                'session_id': str(session.id),
                'ip_address': ip_address,
            })
            
            return access_token, refresh_token, session

    @staticmethod
    def refresh_tokens(
        refresh_token: str,
        ip_address: str,
        user_agent: str = ''
    ) -> Tuple[str, str]:
        """
        Refresh access token using refresh token.
        Returns: (new_access_token, new_refresh_token)
        """
        token_hash = generate_secure_hash(refresh_token)
        
        try:
            token_record = RefreshToken.objects.select_related(
                'user', 'session'
            ).get(token_hash=token_hash)
        except RefreshToken.DoesNotExist:
            raise ServiceException("Invalid refresh token")
        
        if not token_record.is_valid:
            # Possible token reuse attack - revoke entire family
            RefreshToken.objects.filter(
                family_id=token_record.family_id
            ).update(is_revoked=True, revoked_at=timezone.now())
            
            logger.warning("Refresh token reuse detected", extra={
                'family_id': str(token_record.family_id),
                'user_id': str(token_record.user_id),
            })
            
            raise ServiceException("Token has been revoked. Please login again.")
        
        with transaction.atomic():
            # Mark old token as used
            token_record.mark_used()
            token_record.revoke()
            
            # Generate new tokens
            jwt_token = JWTRefreshToken.for_user(token_record.user)
            new_access_token = str(jwt_token.access_token)
            new_refresh_token = str(jwt_token)
            
            # Create new refresh token record
            RefreshToken.objects.create(
                user=token_record.user,
                token_hash=generate_secure_hash(new_refresh_token),
                session=token_record.session,
                family_id=token_record.family_id,
                parent_token=token_record,
                expires_at=token_record.session.expires_at if token_record.session else timezone.now() + timedelta(days=30),
            )
            
            # Update session
            if token_record.session:
                token_record.session.refresh_token_hash = generate_secure_hash(new_refresh_token[:50])
                token_record.session.save(update_fields=['refresh_token_hash', 'last_activity_at'])
            
            return new_access_token, new_refresh_token

    @staticmethod
    def logout_user(user: User, session_id: Optional[str] = None) -> None:
        """
        Logout user from single session.
        """
        with transaction.atomic():
            if session_id:
                # Revoke specific session
                try:
                    session = AuthSession.objects.get(id=session_id, user=user)
                    session.revoke()
                    
                    # Revoke associated refresh tokens
                    RefreshToken.objects.filter(session=session).update(
                        is_revoked=True,
                        revoked_at=timezone.now()
                    )
                except AuthSession.DoesNotExist:
                    raise ServiceException("Session not found")
            else:
                # This shouldn't happen, but handle gracefully
                pass
            
            logger.info(f"User logged out: {user.email}", extra={
                'user_id': str(user.id),
                'session_id': session_id,
            })

    @staticmethod
    def logout_all(user: User) -> int:
        """
        Logout user from all sessions.
        Returns: Number of sessions revoked.
        """
        with transaction.atomic():
            # Revoke all sessions
            sessions = AuthSession.objects.filter(user=user, is_revoked=False)
            session_count = sessions.count()
            sessions.update(is_revoked=True, revoked_at=timezone.now())
            
            # Revoke all refresh tokens
            RefreshToken.objects.filter(user=user, is_revoked=False).update(
                is_revoked=True,
                revoked_at=timezone.now()
            )
            
            logger.info(f"User logged out from all devices: {user.email}", extra={
                'user_id': str(user.id),
                'sessions_revoked': session_count,
            })
            
            return session_count

    @staticmethod
    def change_password(user: User, new_password: str) -> None:
        """
        Change user password and optionally logout all sessions.
        """
        with transaction.atomic():
            user.set_password(new_password)
            user.save(update_fields=['password', 'updated_at'])
            
            # Revoke all sessions for security
            AuthenticationService.logout_all(user)
            
            logger.info(f"User changed password: {user.email}", extra={
                'user_id': str(user.id),
            })

    @staticmethod
    def get_user_sessions(user: User) -> list:
        """
        Get all active sessions for user.
        """
        return AuthSession.objects.filter(
            user=user,
            is_revoked=False,
            expires_at__gt=timezone.now()
        ).order_by('-last_activity_at')

    @staticmethod
    def revoke_session(user: User, session_id: str) -> None:
        """
        Revoke a specific session.
        """
        try:
            session = AuthSession.objects.get(id=session_id, user=user)
            session.revoke()
            
            # Revoke associated refresh tokens
            RefreshToken.objects.filter(session=session).update(
                is_revoked=True,
                revoked_at=timezone.now()
            )
            
            logger.info(f"Session revoked: {session_id}", extra={
                'user_id': str(user.id),
                'session_id': session_id,
            })
        except AuthSession.DoesNotExist:
            raise ServiceException("Session not found")


class MagicLinkService:
    """
    Service for handling magic link authentication.
    """

    @staticmethod
    def request_magic_link(email: str, ip_address: Optional[str] = None) -> bool:
        """
        Request a magic link for email.
        Returns True if magic link was sent (or would be sent).
        We always return True to prevent email enumeration.
        """
        # Check if user exists
        try:
            user = User.objects.get(email=email.lower())
        except User.DoesNotExist:
            # Don't reveal that user doesn't exist
            logger.info(f"Magic link requested for non-existent email: {email}")
            return True
        
        if not user.is_active:
            logger.info(f"Magic link requested for inactive user: {email}")
            return True
        
        # Invalidate any existing magic links
        MagicLink.objects.filter(
            email=email.lower(),
            used_at__isnull=True
        ).delete()
        
        # Create new magic link
        magic_link, token = MagicLink.create_for_email(email.lower(), ip_address)
        
        # Send email (async)
        from .tasks import send_magic_link_email
        send_magic_link_email.delay(str(magic_link.id), token)
        
        logger.info(f"Magic link created: {email}", extra={
            'magic_link_id': str(magic_link.id),
            'ip_address': ip_address,
        })
        
        return True

    @staticmethod
    def verify_magic_link(
        token: str,
        ip_address: str,
        user_agent: str = ''
    ) -> Tuple[User, str, str]:
        """
        Verify magic link and return user with tokens.
        Returns: (user, access_token, refresh_token)
        """
        token_hash = generate_secure_hash(token)
        
        try:
            magic_link = MagicLink.objects.get(token_hash=token_hash)
        except MagicLink.DoesNotExist:
            raise ServiceException("Invalid or expired magic link")
        
        if not magic_link.is_valid:
            raise ServiceException("Magic link has expired or already been used")
        
        # Get user
        try:
            user = User.objects.get(email=magic_link.email)
        except User.DoesNotExist:
            raise ServiceException("User not found")
        
        if not user.is_active:
            raise ServiceException("This account has been deactivated")
        
        with transaction.atomic():
            # Mark magic link as used
            magic_link.mark_used()
            
            # Verify email if not already verified
            if not user.email_verified:
                user.verify_email()
            
            # Login user
            access_token, refresh_token, _ = AuthenticationService.login_user(
                user=user,
                ip_address=ip_address,
                user_agent=user_agent,
            )
            
            logger.info(f"Magic link verified: {user.email}", extra={
                'user_id': str(user.id),
                'magic_link_id': str(magic_link.id),
            })
            
            return user, access_token, refresh_token


class PasswordResetService:
    """
    Service for handling password reset.
    """

    @staticmethod
    def request_password_reset(email: str, ip_address: Optional[str] = None) -> bool:
        """
        Request a password reset link.
        Returns True always to prevent email enumeration.
        """
        # Check if user exists
        try:
            user = User.objects.get(email=email.lower())
        except User.DoesNotExist:
            logger.info(f"Password reset requested for non-existent email: {email}")
            return True
        
        if not user.is_active:
            logger.info(f"Password reset requested for inactive user: {email}")
            return True
        
        # Create token (use MagicLink model for simplicity)
        magic_link, token = MagicLink.create_for_email(email.lower(), ip_address)
        
        # Send email (async)
        from .tasks import send_password_reset_email
        send_password_reset_email.delay(str(user.id), token)
        
        logger.info(f"Password reset requested: {email}", extra={
            'user_id': str(user.id),
            'ip_address': ip_address,
        })
        
        return True

    @staticmethod
    def reset_password(token: str, new_password: str) -> User:
        """
        Reset password using token.
        """
        token_hash = generate_secure_hash(token)
        
        try:
            magic_link = MagicLink.objects.get(token_hash=token_hash)
        except MagicLink.DoesNotExist:
            raise ServiceException("Invalid or expired reset link")
        
        if not magic_link.is_valid:
            raise ServiceException("Reset link has expired or already been used")
        
        # Get user
        try:
            user = User.objects.get(email=magic_link.email)
        except User.DoesNotExist:
            raise ServiceException("User not found")
        
        with transaction.atomic():
            # Mark token as used
            magic_link.mark_used()
            
            # Change password (this also logs out all sessions)
            AuthenticationService.change_password(user, new_password)
            
            logger.info(f"Password reset completed: {user.email}", extra={
                'user_id': str(user.id),
            })
            
            return user


class EmailVerificationService:
    """
    Service for handling email verification.
    """

    @staticmethod
    def request_verification(user: User, ip_address: Optional[str] = None) -> bool:
        """
        Request email verification.
        """
        if user.email_verified:
            return True
        
        # Create verification token
        magic_link, token = MagicLink.create_for_email(user.email, ip_address)
        
        # Send email (async)
        from .tasks import send_email_verification
        send_email_verification.delay(str(user.id), token)
        
        logger.info(f"Email verification requested: {user.email}", extra={
            'user_id': str(user.id),
        })
        
        return True

    @staticmethod
    def verify_email(token: str) -> User:
        """
        Verify email using token.
        """
        token_hash = generate_secure_hash(token)
        
        try:
            magic_link = MagicLink.objects.get(token_hash=token_hash)
        except MagicLink.DoesNotExist:
            raise ServiceException("Invalid or expired verification link")
        
        if not magic_link.is_valid:
            raise ServiceException("Verification link has expired or already been used")
        
        # Get user
        try:
            user = User.objects.get(email=magic_link.email)
        except User.DoesNotExist:
            raise ServiceException("User not found")
        
        with transaction.atomic():
            # Mark token as used
            magic_link.mark_used()
            
            # Verify email
            user.verify_email()
            
            logger.info(f"Email verified: {user.email}", extra={
                'user_id': str(user.id),
            })
            
            return user
```

---

## Authentication Tasks (Celery)

### `apps/authentication/tasks.py`

```python
"""
Celery tasks for authentication.
"""
import logging
from celery import shared_task
from django.core.mail import send_mail
from django.conf import settings
from django.template.loader import render_to_string
from django.utils import timezone
from datetime import timedelta

logger = logging.getLogger(__name__)


@shared_task(bind=True, max_retries=3, default_retry_delay=60)
def send_email_verification(self, user_id: str, token: str = None):
    """
    Send email verification email.
    """
    try:
        from .models import User, MagicLink
        
        user = User.objects.get(id=user_id)
        
        if user.email_verified:
            logger.info(f"Email already verified for user: {user.email}")
            return
        
        # Generate token if not provided
        if not token:
            magic_link, token = MagicLink.create_for_email(user.email)
        
        verification_url = f"https://{settings.DOMAIN}/verify-email?token={token}"
        
        subject = "Verify your email address"
        html_message = render_to_string('emails/email_verification.html', {
            'user': user,
            'verification_url': verification_url,
        })
        plain_message = f"""
Hi {user.display_name},

Please verify your email address by clicking the link below:

{verification_url}

This link will expire in {settings.MAGIC_LINK_EXPIRY_MINUTES} minutes.

If you didn't create an account, you can safely ignore this email.

Best,
The Team
        """
        
        send_mail(
            subject=subject,
            message=plain_message,
            from_email=settings.DEFAULT_FROM_EMAIL,
            recipient_list=[user.email],
            html_message=html_message,
            fail_silently=False,
        )
        
        logger.info(f"Email verification sent to: {user.email}")
        
    except Exception as exc:
        logger.error(f"Failed to send email verification: {exc}")
        raise self.retry(exc=exc)


@shared_task(bind=True, max_retries=3, default_retry_delay=60)
def send_magic_link_email(self, magic_link_id: str, token: str):
    """
    Send magic link email.
    """
    try:
        from .models import MagicLink
        
        magic_link = MagicLink.objects.get(id=magic_link_id)
        
        login_url = f"https://{settings.DOMAIN}/auth/magic-link?token={token}"
        
        subject = "Your login link"
        html_message = render_to_string('emails/magic_link.html', {
            'login_url': login_url,
            'expiry_minutes': settings.MAGIC_LINK_EXPIRY_MINUTES,
        })
        plain_message = f"""
Hi,

Click the link below to log in to your account:

{login_url}

This link will expire in {settings.MAGIC_LINK_EXPIRY_MINUTES} minutes.

If you didn't request this link, you can safely ignore this email.

Best,
The Team
        """
        
        send_mail(
            subject=subject,
            message=plain_message,
            from_email=settings.DEFAULT_FROM_EMAIL,
            recipient_list=[magic_link.email],
            html_message=html_message,
            fail_silently=False,
        )
        
        logger.info(f"Magic link sent to: {magic_link.email}")
        
    except Exception as exc:
        logger.error(f"Failed to send magic link: {exc}")
        raise self.retry(exc=exc)


@shared_task(bind=True, max_retries=3, default_retry_delay=60)
def send_password_reset_email(self, user_id: str, token: str):
    """
    Send password reset email.
    """
    try:
        from .models import User
        
        user = User.objects.get(id=user_id)
        
        reset_url = f"https://{settings.DOMAIN}/auth/reset-password?token={token}"
        
        subject = "Reset your password"
        html_message = render_to_string('emails/password_reset.html', {
            'user': user,
            'reset_url': reset_url,
            'expiry_minutes': settings.MAGIC_LINK_EXPIRY_MINUTES,
        })
        plain_message = f"""
Hi {user.display_name},

You requested to reset your password. Click the link below to set a new password:

{reset_url}

This link will expire in {settings.MAGIC_LINK_EXPIRY_MINUTES} minutes.

If you didn't request a password reset, you can safely ignore this email.

Best,
The Team
        """
        
        send_mail(
            subject=subject,
            message=plain_message,
            from_email=settings.DEFAULT_FROM_EMAIL,
            recipient_list=[user.email],
            html_message=html_message,
            fail_silently=False,
        )
        
        logger.info(f"Password reset email sent to: {user.email}")
        
    except Exception as exc:
        logger.error(f"Failed to send password reset email: {exc}")
        raise self.retry(exc=exc)


@shared_task(bind=True, max_retries=3, default_retry_delay=60)
def send_password_changed_notification(self, user_id: str, ip_address: str = None):
    """
    Send password changed notification email.
    """
    try:
        from .models import User
        
        user = User.objects.get(id=user_id)
        
        subject = "Your password has been changed"
        html_message = render_to_string('emails/password_changed.html', {
            'user': user,
            'ip_address': ip_address,
        })
        plain_message = f"""
Hi {user.display_name},

Your password was recently changed. If you made this change, no further action is needed.

If you didn't change your password, please reset your password immediately and contact support.

Best,
The Team
        """
        
        send_mail(
            subject=subject,
            message=plain_message,
            from_email=settings.DEFAULT_FROM_EMAIL,
            recipient_list=[user.email],
            html_message=html_message,
            fail_silently=False,
        )
        
        logger.info(f"Password changed notification sent to: {user.email}")
        
    except Exception as exc:
        logger.error(f"Failed to send password changed notification: {exc}")
        raise self.retry(exc=exc)


@shared_task
def cleanup_expired_sessions():
    """
    Cleanup expired sessions and tokens.
    Runs daily via celery beat.
    """
    from .models import AuthSession, RefreshToken, MagicLink
    
    now = timezone.now()
    
    # Delete expired sessions (older than 30 days past expiry)
    old_sessions = AuthSession.objects.filter(
        expires_at__lt=now - timedelta(days=30)
    )
    session_count = old_sessions.count()
    old_sessions.delete()
    
    # Delete expired refresh tokens (older than 30 days past expiry)
    old_tokens = RefreshToken.objects.filter(
        expires_at__lt=now - timedelta(days=30)
    )
    token_count = old_tokens.count()
    old_tokens.delete()
    
    # Delete old magic links (older than 7 days)
    old_magic_links = MagicLink.objects.filter(
        created_at__lt=now - timedelta(days=7)
    )
    magic_link_count = old_magic_links.count()
    old_magic_links.delete()
    
    logger.info(
        f"Cleanup completed: {session_count} sessions, "
        f"{token_count} tokens, {magic_link_count} magic links deleted"
    )
```

---

## Authentication Views

### `apps/authentication/views.py`

```python
"""
Authentication views.
"""
import logging
from rest_framework import status, generics
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework_simplejwt.views import TokenRefreshView
from drf_spectacular.utils import extend_schema, OpenApiResponse
from django.utils.decorators import method_decorator
from django.views.decorators.csrf import csrf_exempt

from .serializers import (
    UserSerializer,
    UserProfileUpdateSerializer,
    UserRegistrationSerializer,
    LoginSerializer,
    PasswordChangeSerializer,
    PasswordResetRequestSerializer,
    PasswordResetConfirmSerializer,
    MagicLinkRequestSerializer,
    MagicLinkVerifySerializer,
    EmailVerificationRequestSerializer,
    EmailVerificationConfirmSerializer,
    AuthSessionSerializer,
    LogoutSerializer,
    LogoutAllSerializer,
)
from .services import (
    AuthenticationService,
    MagicLinkService,
    PasswordResetService,
    EmailVerificationService,
)

logger = logging.getLogger(__name__)


def get_client_ip(request):
    """Get client IP from request."""
    x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
    if x_forwarded_for:
        return x_forwarded_for.split(',')[0].strip()
    return request.META.get('REMOTE_ADDR')


@extend_schema(tags=['Authentication'])
class RegisterView(generics.CreateAPIView):
    """
    Register a new user account.
    """
    permission_classes = [AllowAny]
    serializer_class = UserRegistrationSerializer

    @extend_schema(
        summary="Register new user",
        responses={
            201: OpenApiResponse(description="User created successfully"),
            400: OpenApiResponse(description="Validation error"),
        }
    )
    def post(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        user = AuthenticationService.register_user(
            email=serializer.validated_data['email'],
            display_name=serializer.validated_data['display_name'],
            password=serializer.validated_data['password'],
            ip_address=get_client_ip(request),
        )
        
        # Auto-login after registration
        access_token, refresh_token, _ = AuthenticationService.login_user(
            user=user,
            ip_address=get_client_ip(request),
            user_agent=request.META.get('HTTP_USER_AGENT', ''),
        )
        
        return Response({
            'data': {
                'user': UserSerializer(user).data,
                'access_token': access_token,
                'refresh_token': refresh_token,
            },
            'message': 'Registration successful. Please verify your email.',
        }, status=status.HTTP_201_CREATED)


@extend_schema(tags=['Authentication'])
class LoginView(APIView):
    """
    Login with email and password.
    """
    permission_classes = [AllowAny]
    serializer_class = LoginSerializer

    @extend_schema(
        summary="Login with email/password",
        request=LoginSerializer,
        responses={
            200: OpenApiResponse(description="Login successful"),
            400: OpenApiResponse(description="Invalid credentials"),
        }
    )
    def post(self, request):
        serializer = LoginSerializer(data=request.data, context={'request': request})
        serializer.is_valid(raise_exception=True)
        
        user = serializer.validated_data['user']
        
        access_token, refresh_token, session = AuthenticationService.login_user(
            user=user,
            ip_address=get_client_ip(request),
            user_agent=request.META.get('HTTP_USER_AGENT', ''),
        )
        
        return Response({
            'data': {
                'user': UserSerializer(user).data,
                'access_token': access_token,
                'refresh_token': refresh_token,
                'session_id': str(session.id),
            }
        })


@extend_schema(tags=['Authentication'])
class LogoutView(APIView):
    """
    Logout current session.
    """
    permission_classes = [IsAuthenticated]
    serializer_class = LogoutSerializer

    @extend_schema(
        summary="Logout current session",
        responses={
            200: OpenApiResponse(description="Logout successful"),
        }
    )
    def post(self, request):
        session_id = request.headers.get('X-Session-ID')
        
        if session_id:
            AuthenticationService.logout_user(request.user, session_id)
        
        return Response({
            'message': 'Logout successful'
        })


@extend_schema(tags=['Authentication'])
class LogoutAllView(APIView):
    """
    Logout from all devices.
    """
    permission_classes = [IsAuthenticated]
    serializer_class = LogoutAllSerializer

    @extend_schema(
        summary="Logout from all devices",
        responses={
            200: OpenApiResponse(description="Logged out from all devices"),
        }
    )
    def post(self, request):
        sessions_revoked = AuthenticationService.logout_all(request.user)
        
        return Response({
            'message': f'Logged out from {sessions_revoked} session(s)',
            'data': {
                'sessions_revoked': sessions_revoked,
            }
        })


@extend_schema(tags=['Authentication'])
class TokenRefreshAPIView(TokenRefreshView):
    """
    Refresh access token using refresh token.
    """
    @extend_schema(
        summary="Refresh access token",
        responses={
            200: OpenApiResponse(description="Token refreshed successfully"),
            401: OpenApiResponse(description="Invalid refresh token"),
        }
    )
    def post(self, request, *args, **kwargs):
        return super().post(request, *args, **kwargs)


@extend_schema(tags=['Authentication'])
class MagicLinkRequestView(APIView):
    """
    Request a magic link for passwordless login.
    """
    permission_classes = [AllowAny]
    serializer_class = MagicLinkRequestSerializer

    @extend_schema(
        summary="Request magic link",
        request=MagicLinkRequestSerializer,
        responses={
            200: OpenApiResponse(description="Magic link sent if email exists"),
        }
    )
    def post(self, request):
        serializer = MagicLinkRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        MagicLinkService.request_magic_link(
            email=serializer.validated_data['email'],
            ip_address=get_client_ip(request),
        )
        
        return Response({
            'message': 'If an account with this email exists, a magic link has been sent.'
        })


@extend_schema(tags=['Authentication'])
class MagicLinkVerifyView(APIView):
    """
    Verify magic link and login.
    """
    permission_classes = [AllowAny]
    serializer_class = MagicLinkVerifySerializer

    @extend_schema(
        summary="Verify magic link",
        request=MagicLinkVerifySerializer,
        responses={
            200: OpenApiResponse(description="Login successful"),
            400: OpenApiResponse(description="Invalid or expired magic link"),
        }
    )
    def post(self, request):
        serializer = MagicLinkVerifySerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        user, access_token, refresh_token = MagicLinkService.verify_magic_link(
            token=serializer.validated_data['token'],
            ip_address=get_client_ip(request),
            user_agent=request.META.get('HTTP_USER_AGENT', ''),
        )
        
        return Response({
            'data': {
                'user': UserSerializer(user).data,
                'access_token': access_token,
                'refresh_token': refresh_token,
            }
        })


@extend_schema(tags=['Authentication'])
class PasswordChangeView(APIView):
    """
    Change password for authenticated user.
    """
    permission_classes = [IsAuthenticated]
    serializer_class = PasswordChangeSerializer

    @extend_schema(
        summary="Change password",
        request=PasswordChangeSerializer,
        responses={
            200: OpenApiResponse(description="Password changed successfully"),
            400: OpenApiResponse(description="Validation error"),
        }
    )
    def post(self, request):
        serializer = PasswordChangeSerializer(
            data=request.data,
            context={'request': request}
        )
        serializer.is_valid(raise_exception=True)
        
        AuthenticationService.change_password(
            user=request.user,
            new_password=serializer.validated_data['new_password'],
        )
        
        # Send notification
        from .tasks import send_password_changed_notification
        send_password_changed_notification.delay(
            str(request.user.id),
            get_client_ip(request)
        )
        
        return Response({
            'message': 'Password changed successfully. Please login again.'
        })


@extend_schema(tags=['Authentication'])
class PasswordResetRequestView(APIView):
    """
    Request password reset email.
    """
    permission_classes = [AllowAny]
    serializer_class = PasswordResetRequestSerializer

    @extend_schema(
        summary="Request password reset",
        request=PasswordResetRequestSerializer,
        responses={
            200: OpenApiResponse(description="Reset email sent if account exists"),
        }
    )
    def post(self, request):
        serializer = PasswordResetRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        PasswordResetService.request_password_reset(
            email=serializer.validated_data['email'],
            ip_address=get_client_ip(request),
        )
        
        return Response({
            'message': 'If an account with this email exists, a reset link has been sent.'
        })


@extend_schema(tags=['Authentication'])
class PasswordResetConfirmView(APIView):
    """
    Reset password using token.
    """
    permission_classes = [AllowAny]
    serializer_class = PasswordResetConfirmSerializer

    @extend_schema(
        summary="Confirm password reset",
        request=PasswordResetConfirmSerializer,
        responses={
            200: OpenApiResponse(description="Password reset successful"),
            400: OpenApiResponse(description="Invalid or expired token"),
        }
    )
    def post(self, request):
        serializer = PasswordResetConfirmSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        user = PasswordResetService.reset_password(
            token=serializer.validated_data['token'],
            new_password=serializer.validated_data['password'],
        )
        
        return Response({
            'message': 'Password reset successful. Please login with your new password.'
        })


@extend_schema(tags=['Authentication'])
class EmailVerificationRequestView(APIView):
    """
    Request email verification.
    """
    permission_classes = [IsAuthenticated]
    serializer_class = EmailVerificationRequestSerializer

    @extend_schema(
        summary="Request email verification",
        responses={
            200: OpenApiResponse(description="Verification email sent"),
        }
    )
    def post(self, request):
        EmailVerificationService.request_verification(
            user=request.user,
            ip_address=get_client_ip(request),
        )
        
        return Response({
            'message': 'Verification email sent.'
        })


@extend_schema(tags=['Authentication'])
class EmailVerificationConfirmView(APIView):
    """
    Confirm email verification.
    """
    permission_classes = [AllowAny]
    serializer_class = EmailVerificationConfirmSerializer

    @extend_schema(
        summary="Confirm email verification",
        request=EmailVerificationConfirmSerializer,
        responses={
            200: OpenApiResponse(description="Email verified successfully"),
            400: OpenApiResponse(description="Invalid or expired token"),
        }
    )
    def post(self, request):
        serializer = EmailVerificationConfirmSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        user = EmailVerificationService.verify_email(
            token=serializer.validated_data['token'],
        )
        
        return Response({
            'message': 'Email verified successfully.',
            'data': {
                'user': UserSerializer(user).data,
            }
        })


@extend_schema(tags=['User'])
class CurrentUserView(APIView):
    """
    Get or update current user profile.
    """
    permission_classes = [IsAuthenticated]

    @extend_schema(
        summary="Get current user profile",
        responses={200: UserSerializer}
    )
    def get(self, request):
        return Response({
            'data': UserSerializer(request.user).data
        })

    @extend_schema(
        summary="Update current user profile",
        request=UserProfileUpdateSerializer,
        responses={200: UserSerializer}
    )
    def patch(self, request):
        serializer = UserProfileUpdateSerializer(
            request.user,
            data=request.data,
            partial=True
        )
        serializer.is_valid(raise_exception=True)
        serializer.save()
        
        return Response({
            'data': UserSerializer(request.user).data,
            'message': 'Profile updated successfully.'
        })


@extend_schema(tags=['User'])
class UserSessionsView(APIView):
    """
    List and manage user sessions.
    """
    permission_classes = [IsAuthenticated]
    serializer_class = AuthSessionSerializer

    @extend_schema(
        summary="List active sessions",
        responses={200: AuthSessionSerializer(many=True)}
    )
    def get(self, request):
        sessions = AuthenticationService.get_user_sessions(request.user)
        serializer = AuthSessionSerializer(
            sessions,
            many=True,
            context={'request': request}
        )
        
        return Response({
            'data': serializer.data
        })


@extend_schema(tags=['User'])
class UserSessionDeleteView(APIView):
    """
    Delete a specific session.
    """
    permission_classes = [IsAuthenticated]

    @extend_schema(
        summary="Delete specific session",
        responses={
            200: OpenApiResponse(description="Session deleted"),
            404: OpenApiResponse(description="Session not found"),
        }
    )
    def delete(self, request, session_id):
        AuthenticationService.revoke_session(request.user, session_id)
        
        return Response({
            'message': 'Session deleted successfully.'
        })
```

---

## Authentication URLs

### `apps/authentication/urls.py`

```python
"""
Authentication URL patterns.
"""
from django.urls import path
from .views import (
    RegisterView,
    LoginView,
    LogoutView,
    LogoutAllView,
    TokenRefreshAPIView,
    MagicLinkRequestView,
    MagicLinkVerifyView,
    PasswordChangeView,
    PasswordResetRequestView,
    PasswordResetConfirmView,
    EmailVerificationRequestView,
    EmailVerificationConfirmView,
    CurrentUserView,
    UserSessionsView,
    UserSessionDeleteView,
)

app_name = 'authentication'

urlpatterns = [
    # Registration
    path('register/', RegisterView.as_view(), name='register'),
    
    # Login/Logout
    path('login/', LoginView.as_view(), name='login'),
    path('logout/', LogoutView.as_view(), name='logout'),
    path('logout-all/', LogoutAllView.as_view(), name='logout-all'),
    
    # Token refresh
    path('refresh/', TokenRefreshAPIView.as_view(), name='token-refresh'),
    
    # Magic link
    path('magic-link/request/', MagicLinkRequestView.as_view(), name='magic-link-request'),
    path('magic-link/verify/', MagicLinkVerifyView.as_view(), name='magic-link-verify'),
    
    # Password management
    path('password/change/', PasswordChangeView.as_view(), name='password-change'),
    path('password/reset/request/', PasswordResetRequestView.as_view(), name='password-reset-request'),
    path('password/reset/confirm/', PasswordResetConfirmView.as_view(), name='password-reset-confirm'),
    
    # Email verification
    path('verify-email/request/', EmailVerificationRequestView.as_view(), name='verify-email-request'),
    path('verify-email/confirm/', EmailVerificationConfirmView.as_view(), name='verify-email-confirm'),
    
    # User profile and sessions
    path('users/me/', CurrentUserView.as_view(), name='current-user'),
    path('sessions/', UserSessionsView.as_view(), name='user-sessions'),
    path('sessions/<uuid:session_id>/', UserSessionDeleteView.as_view(), name='delete-session'),
]
```

---

## Authentication Backends

### `apps/authentication/backends.py`

```python
"""
Custom authentication backends.
"""
from django.contrib.auth.backends import ModelBackend
from django.contrib.auth import get_user_model

User = get_user_model()


class EmailBackend(ModelBackend):
    """
    Custom authentication backend that uses email instead of username.
    """
    def authenticate(self, request, email=None, password=None, **kwargs):
        if email is None:
            email = kwargs.get('username')
        
        if email is None or password is None:
            return None
        
        try:
            user = User.objects.get(email=email.lower())
        except User.DoesNotExist:
            # Run the default password hasher to reduce timing attacks
            User().set_password(password)
            return None
        
        if user.check_password(password) and self.user_can_authenticate(user):
            return user
        
        return None

    def get_user(self, user_id):
        try:
            return User.objects.get(pk=user_id)
        except User.DoesNotExist:
            return None
```

### Update `config/settings/base.py` to add:

```python
# Authentication backends
AUTHENTICATION_BACKENDS = [
    'apps.authentication.backends.EmailBackend',
    'django.contrib.auth.backends.ModelBackend',
]
```

---

## Authentication Signals

### `apps/authentication/signals.py`

```python
"""
Authentication signals.
"""
import logging
from django.db.models.signals import post_save
from django.dispatch import receiver
from .models import User

logger = logging.getLogger(__name__)


@receiver(post_save, sender=User)
def user_created(sender, instance, created, **kwargs):
    """
    Handle user creation.
    """
    if created:
        logger.info(f"New user created: {instance.email}", extra={
            'user_id': str(instance.id),
            'email': instance.email,
        })
```

---

## Authentication Admin

### `apps/authentication/admin.py`

```python
"""
Admin configuration for authentication models.
"""
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from django.utils.translation import gettext_lazy as _
from .models import User, UserIdentity, AuthSession, RefreshToken, MagicLink


@admin.register(User)
class UserAdmin(BaseUserAdmin):
    """
    Admin for custom User model.
    """
    list_display = [
        'email', 
        'display_name', 
        'email_verified', 
        'is_active', 
        'is_staff',
        'created_at',
    ]
    list_filter = [
        'is_active', 
        'is_staff', 
        'is_superuser', 
        'email_verified',
        'created_at',
    ]
    search_fields = ['email', 'display_name']
    ordering = ['-created_at']
    readonly_fields = ['id', 'created_at', 'updated_at', 'last_login_at']
    
    fieldsets = (
        (None, {'fields': ('id', 'email', 'password')}),
        (_('Personal info'), {'fields': ('display_name', 'avatar_url', 'timezone', 'locale')}),
        (_('Permissions'), {
            'fields': ('is_active', 'is_staff', 'is_superuser', 'groups', 'user_permissions'),
        }),
        (_('Verification'), {'fields': ('email_verified', 'email_verified_at')}),
        (_('Important dates'), {'fields': ('last_login_at', 'created_at', 'updated_at')}),
        (_('Metadata'), {'fields': ('metadata',)}),
    )
    
    add_fieldsets = (
        (None, {
            'classes': ('wide',),
            'fields': ('email', 'display_name', 'password1', 'password2'),
        }),
    )


@admin.register(UserIdentity)
class UserIdentityAdmin(admin.ModelAdmin):
    """
    Admin for UserIdentity model.
    """
    list_display = ['user', 'provider', 'provider_user_id', 'verified', 'created_at']
    list_filter = ['provider', 'verified']
    search_fields = ['user__email', 'provider_user_id']
    readonly_fields = ['id', 'created_at', 'updated_at']


@admin.register(AuthSession)
class AuthSessionAdmin(admin.ModelAdmin):
    """
    Admin for AuthSession model.
    """
    list_display = [
        'user', 
        'ip_address', 
        'is_revoked', 
        'last_activity_at',
        'expires_at',
        'created_at',
    ]
    list_filter = ['is_revoked', 'created_at']
    search_fields = ['user__email', 'ip_address']
    readonly_fields = [
        'id', 
        'token_hash', 
        'refresh_token_hash',
        'created_at', 
        'updated_at',
    ]
    raw_id_fields = ['user']
    
    def has_add_permission(self, request):
        return False


@admin.register(RefreshToken)
class RefreshTokenAdmin(admin.ModelAdmin):
    """
    Admin for RefreshToken model.
    """
    list_display = [
        'user',
        'family_id',
        'is_revoked',
        'used_at',
        'expires_at',
        'created_at',
    ]
    list_filter = ['is_revoked', 'created_at']
    search_fields = ['user__email']
    readonly_fields = ['id', 'token_hash', 'created_at', 'updated_at']
    raw_id_fields = ['user', 'session', 'parent_token']
    
    def has_add_permission(self, request):
        return False


@admin.register(MagicLink)
class MagicLinkAdmin(admin.ModelAdmin):
    """
    Admin for MagicLink model.
    """
    list_display = ['email', 'used_at', 'expires_at', 'created_at']
    list_filter = ['created_at']
    search_fields = ['email']
    readonly_fields = ['id', 'token', 'token_hash', 'created_at', 'updated_at']
    
    def has_add_permission(self, request):
        return False
```

---

## Email Templates

### `templates/emails/base_email.html`

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}{% endblock %}</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            text-align: center;
            padding: 20px 0;
            border-bottom: 1px solid #eee;
        }
        .content {
            padding: 30px 0;
        }
        .button {
            display: inline-block;
            padding: 12px 30px;
            background-color: #007bff;
            color: #ffffff !important;
            text-decoration: none;
            border-radius: 5px;
            margin: 20px 0;
        }
        .footer {
            text-align: center;
            padding: 20px 0;
            border-top: 1px solid #eee;
            color: #666;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>{% block header %}SaaS Platform{% endblock %}</h1>
    </div>
    
    <div class="content">
        {% block content %}{% endblock %}
    </div>
    
    <div class="footer">
        {% block footer %}
        <p>&copy; {{ current_year }} SaaS Platform. All rights reserved.</p>
        {% endblock %}
    </div>
</body>
</html>
```

### `templates/emails/email_verification.html`

```html
{% extends "emails/base_email.html" %}

{% block title %}Verify Your Email{% endblock %}

{% block content %}
<h2>Hi {{ user.display_name }},</h2>

<p>Thank you for creating an account. Please verify your email address by clicking the button below:</p>

<p style="text-align: center;">
    <a href="{{ verification_url }}" class="button">Verify Email Address</a>
</p>

<p>Or copy and paste this link into your browser:</p>
<p style="word-break: break-all;">{{ verification_url }}</p>

<p>This link will expire in 15 minutes.</p>

<p>If you didn't create an account, you can safely ignore this email.</p>

<p>Best,<br>The Team</p>
{% endblock %}
```

### `templates/emails/magic_link.html`

```html
{% extends "emails/base_email.html" %}

{% block title %}Your Login Link{% endblock %}

{% block content %}
<h2>Hi,</h2>

<p>Click the button below to log in to your account:</p>

<p style="text-align: center;">
    <a href="{{ login_url }}" class="button">Log In</a>
</p>

<p>Or copy and paste this link into your browser:</p>
<p style="word-break: break-all;">{{ login_url }}</p>

<p>This link will expire in {{ expiry_minutes }} minutes.</p>

<p>If you didn't request this link, you can safely ignore this email.</p>

<p>Best,<br>The Team</p>
{% endblock %}
```

### `templates/emails/password_reset.html`

```html
{% extends "emails/base_email.html" %}

{% block title %}Reset Your Password{% endblock %}

{% block content %}
<h2>Hi {{ user.display_name }},</h2>

<p>You requested to reset your password. Click the button below to set a new password:</p>

<p style="text-align: center;">
    <a href="{{ reset_url }}" class="button">Reset Password</a>
</p>

<p>Or copy and paste this link into your browser:</p>
<p style="word-break: break-all;">{{ reset_url }}</p>

<p>This link will expire in {{ expiry_minutes }} minutes.</p>

<p>If you didn't request a password reset, you can safely ignore this email. Your password will remain unchanged.</p>

<p>Best,<br>The Team</p>
{% endblock %}
```

### `templates/emails/password_changed.html`

```html
{% extends "emails/base_email.html" %}

{% block title %}Password Changed{% endblock %}

{% block content %}
<h2>Hi {{ user.display_name }},</h2>

<p>Your password was recently changed.</p>

{% if ip_address %}
<p>This change was made from IP address: {{ ip_address }}</p>
{% endif %}

<p>If you made this change, no further action is needed.</p>

<p><strong>If you didn't change your password:</strong></p>
<ol>
    <li>Reset your password immediately</li>
    <li>Contact our support team</li>
</ol>

<p>Best,<br>The Team</p>
{% endblock %}
```

---

## Phase 2 Part 2 Complete!

This covers:
-  All authentication serializers
-  Complete authentication services
-  Celery tasks for emails
-  All authentication views and endpoints
-  URL configuration
-  Custom authentication backend
-  Signals for user events
-  Admin configuration
-  Email templates

**API Endpoints Implemented:**
- `POST /api/v1/auth/register/` - Register new user
- `POST /api/v1/auth/login/` - Login with email/password
- `POST /api/v1/auth/logout/` - Logout current session
- `POST /api/v1/auth/logout-all/` - Logout from all devices
- `POST /api/v1/auth/refresh/` - Refresh access token
- `POST /api/v1/auth/magic-link/request/` - Request magic link
- `POST /api/v1/auth/magic-link/verify/` - Verify magic link
- `POST /api/v1/auth/password/change/` - Change password
- `POST /api/v1/auth/password/reset/request/` - Request password reset
- `POST /api/v1/auth/password/reset/confirm/` - Confirm password reset
- `POST /api/v1/auth/verify-email/request/` - Request email verification
- `POST /api/v1/auth/verify-email/confirm/` - Confirm email verification
- `GET/PATCH /api/v1/auth/users/me/` - Get/update current user
- `GET /api/v1/auth/sessions/` - List active sessions
- `DELETE /api/v1/auth/sessions/{id}/` - Delete session

**Ready for Phase 3?** Reply "Continue" and I'll implement:
- Organizations app (models, serializers, views)
- Organization membership
- Organization settings
- Teams app